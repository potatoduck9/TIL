# 번역기의 종류
* 컴파일러와 인간이 의사 전달을 하기 위해서는 C, C++, JAVA 같은 고급언어가 필요하고, 이러한 고급언어로 작성된 프로그램을 컴퓨터가 인식할 수 있도록 저급언어로 번역해 주기 위해선 번역기가 필요하다.  
* 번역기의 종류에는 어셈블러, 컴파일러, 인터프리터, 프리프로세스 등이 있으며 이 중에서 가장 대표적인 번역기가 컴파일러이다. 
* 어셈블러는 번역기에 어셈블리어가 입력되면 기계어로 번역을 해준다. 
* 컴파일러는 고급언어를 저급언어로 번역을 해준다. 
* 인터프리터는 고급언어를 실행 결과로 번역을 해준다. (고급언어를 입력으로 받아들여서 번역과 동시에 실행을 한 후, 결과를 출력하기 때문에 APL, SNOBOL 등과 같은 대화용 언어를 구현할 경우 사용)
* 프리프로세서는 고급언어를 고급언어로 번역을 해준다. (프로그래밍 언어에 유용한 기능들을 추가하여 확장시켜 주는 역할을 함)

# 컴파일러와 인터프리터 
* 번역기들 중에서 고급언어로 작성된 프로그램을 입력 자료로 하여 번역하는 가장 대표적인 번역기는 컴파일러와 인터프리터이다. 
* 컴파일러 기법은 번역 후 실행하는 방식이고 인터프리터 기법은 번역과 실행을 동시에 하는 방식이다. (컴파일러가 번역기라면 인터프리터는 통역기인 셈)
* 컴파일러 기법은 번역 후 실행을 한 번에 하기 때문에 실행 속도가 빠른 장점이 있고 반복문 처리에도 효과가 있다. 반면 인터프리터 기법은 번역과 실행을 동시에 하기에 반복문 처리에는 적합하지 않다.
  * 컴파일러 기법을 사용하는 언어의 종류에는 PASCAL, C, C++, JAVA 등이 있다.
* 인터프리터 기법은 번역과 실행을 동시에 하기 때문에 한 줄 번역하고 실행하고 한 줄 번역하고 실행하기에 실행 시간이 긴 단점이 있지만 번역과 실행을 수행한 후 사용자에게 권한을 넘겨줘 사용자가 추가하고 싶은 것을 입력할 수 있는 장점도 있다. (사용자와 대화식) 반면 컴파일러 기법은 번역 후 한 실행을 한 번에 하기 때문에 사용자에게 권한을 주지 않는다. 
  * 인터프리터 기법을 사용하는 언어의 종류에는 LISP, APL, SNOBOL 등이 있다.

 # 컴파일러 논리적 구조 
 * 컴파일러는 일반적으로, 어휘 분석(lexical analysis) 단계, 구문 분석(syntax analysis) 단계, 의미 분석(semantic analysis) 단계, 중간 코드 생성(intermediate code generation) 단계, 코드 최적화(code optimization) 단계, 목적 코드 생성(code generation) 단계를 거쳐 저급언어로 번역된다.
 * 어휘 분석 단계에서는 기본어휘가 문법에 맞는지 분석하고 어휘를 토큰으로 변환한다.
 * 구문 분석 단계에서는 토큰으로 변환된 것 들이 문법에 맞는지 분석하고 분석 결과를 파스 트리로 출력한다.
 * 의미 분석 단계에서는 자료구조정의, 혼합형연산 등의 실행 전 사전작업을 해주고 컴파일러가 올바르게 수행될 수 있도록 환경을 조성한다.
 * 의미 분석 단계까지의 내용으로 코드를 생성해도 되지만 좀더 효율적으로 만들어 실행시 기억공간이나 실행시간을 절약하는 것이 필요하다. 이를 수행하는 것이 코드최적화이고 코드최적화가 되기 위해선 그 전에 중간코드가 생성되어야 한다. 중간코드는 최적화를 위한 중간단계이며 후위표현, 3주소코드, U코드, 문법지시적변환 등의 방식들을 사용하여 시간과 공간의 크기를 줄여준다.
 * 마지막 목적 코드 생성 단계에서는 최적화된 코드를 그대로 레지스터나 기억장소 위치를 정해서 목적코드로 생성해준다.

# 컴파일러 패스
* 패스란 컴파일러를 구현할 때 여러 논리적 단계들을 모아서 하나의 물리적 모듈로 묶은 것이다.
* 컴파일러는 위에서 말한 6단계의 논리적인 구조를 가지고 있고 이런 논리적인 구조를 실제 구현하게 되는 경우 1-패스 컴파일러 또는 2-패스 컴파일러 방법을 이용한다.
* 어휘 분석에서 중간 코드 단계까지 묶은 것을 1패스 최적화 단계에서 코드 생성 단계까지 묶은 것을 2패스라고 할 때 1-패스 컴파일러는 1패스와 2패스를 합해서 하나의 패스로 구성하는 방식이고 2-패스 컴파일러는 중간 코드를 기점으로 하여 전반부(1패스)와 후반부(2패스)로 구성하는 방식이다.
* 1-패스 컴파일러는 초창기에 컴파일러를 만들 때 사용되던 방식이다. 이 방식의 특징에는 실행 속도가 빠르고 효율성이 높은 장점이 있지만 backpatching이 요구되는 문제점도 있다.
  * backpatching(GOTO 문의 전방 점프나 IF 분기 구문 같은 경우에는 내부적으로 점프를 사용하는데 점프할 부분의 소스 코드가 읽히지 않으면 점프의 번지를 지정할 수 없는 상태이므로 중간 코드에 빠진 부분을 만들어 놓고 해당 점프의 목표 부분을 찾으면 점프의 번지를 결정한다)
* 2-패스 컴파일러는 컴파일러의 구성을 중간 코드를 기점으로 하여 앞 단계를 전반부, 뒤 단계를 후반부로 구성하는 방식이다. 이 방식의 특징에는 컴파일러의 구성을 2단계로 나누었기 때문에 기계 독립적이고 이식성이 좋으며 기억장소를 절약할 수 있는 장점이 있지만 실행 속도가 느린 문제점도 있다.

# 유한 오토마타 
* 유한 오토마타란 어떤 알파벳 T로부터 만들어지는 문자열의 특별한 것들을 받아들이는 시스템의 수학적 모델로서, 그 시스템의 변화할 수 있는 상태가 유한 개인 것이다.
* 유한 오토마타는 입력으로 문자열을 받아서, 그 문자열이 그 언어의 문장이면 "YES"를 답하고 그렇지 않으면 "NO"라고 답하는 프로그램으로 어휘 분석기는 유한 오토마타의 대표적인 예이다.
* 유한 오토마타를 표현하는 방식은 두 가지가 있다. 첫 번째 방식은 정의에 따라서 5가지의 구성 원소들을 형식(formal)에 맞게 정확히 표현하고 두 번째 방식은 상태전이도를 사용하여 비형식적(informal)으로 표현하는 방법인데 이 방식은 그림을 통하여 쉽게 개념이 들어오기 때문에 일반적으로 유한 오토마타를 설명할 때 상태전이도를 많이 사용한다.
![컴파일러](https://github.com/potatoduck9/TIL/assets/125454578/3607f5a1-72ed-4a52-872c-4846df8cf6ad)
* 위 그림은 유한 오토마타를 상태전이도를 사용하여 비형식적으로 표현하는 방법을 나타낸 것이다. 오토마타의 각 상태(state)를 노드로 나타내며(위 그림에서는 q₀, q₁) q₀에서 q₁으로 가는 지시선과 지시선 위에 영문자 입력 기호를 적는다. q₁은 종료 상태이기 때문에 이중 원으로 나타내고 q₀ 노드전에는 시작 상태를 표시하는 start 선을 하나 그려준다.
![컴파일러2](https://github.com/potatoduck9/TIL/assets/125454578/9e592c68-7cf7-4d32-a562-5f0475986e7f)
* 위 그림은 식별자를 c3a9로 가정하고 답을 어떻게 하는지 알아보는 그림이다. q₀에서  q₁으로 가는 지시선에 입력 문자 c가 있기 때문에 q₀에서 q₁으로 이동하고, 남은 식별자인 3a9는 q₁ 입력문자에 모두 있기 때문에 q₁에서 식별자를 모두 인식하고 마지막에 종료 상태가 된다.
* 예를 들어 식별자가 a = 7이라고 가정한다면 a는 입력 기호에 있기 때문에 q₀에서 q₁으로 이동할 수 있지만 다음 식별자인 기호 =는 q₁에서 인식을 하지 못하기 때문에 식별자가 아니다(NO)로 답한다.
* 유한 오토마타를 표현하는 또 다른 방식인 형식에 맞게 표현한다면 밑에 있는 기호들로 표현할 수 있다. 
   >M = (Q, Σ, δ, q₀, F) <br>
   >단 , Q = {q₀, q₁} <br>
   >Σ = {a,b,c,...,z,0,1,...,9} <br>
   >q₀ = q₀ F = {q₁} <br>
* 위에 있는 기호에서 Q는 상태를 의미하고 Σ는 입력 기호를 의미하고 δ는 전이 함수를 의미하고 q₀는 시작 상태 F는 종료 상태를 의미한다.
* 전이 함수를 의미하는 δ를 표현하면 밑의 식으로 표현할 수 있다.
>δ| a  b  c ...  z   |  0   1 .... 9 <br>
>q₀|q₁ q₁ q₁...q₁   | ø   ø.... ø <br>
>q₁|q₁ q₁ q₁...q₁   | q₁  q₁...q₁ <br>
* 입력 문자 a, b, c...z를 입력받으면 q₀에서 q₁으로 이동하기 때문에 q₁을 표시하고 숫자를 받으면 아무 곳으로 이동하지 못하기 때문에 공집합으로 표시한다. q₁은 영문자, 숫자를 입력받으면 q₁으로 이동할 수 있기 때문에 q₁을 표시한다.
# 유한 오토마타의 종류 
* 유한 오토마타의 종류에는 결정적 유한 오토마타(DFA)와 비결정적 유한 오토마타(NFA)가 있다.
  * 결정적 유한 오토마타는 하나의 입력 문자열에 대하여 오직 하나의 다음 상태가 결정되는 유한 오토마타이다.
  * 비결정적 유한 오토마타는 두 가지가 있는데 하나는 ε에 의한 전이가 있는 경우가 있고 또 다른 하나는 주어진 하나의 입력 기호를 보고 갈 수 있는 다음 상태가 두 개 이상 존재할 수 있는 유한 오토마타이다.
* 비결정적 유한 오토마타(NFA)는 언어의 구조를 쉽게 표현할 수 있지만 결정적 유한 오토마타(DFA)보다 프로그램으로 구현하기 힘들다. 반면 DFA는 NFA보다 프로그램으로 구현했을 때 효율 면에서 좋다. 그렇기 때문에 언어의 구조를 표현할 때는 NFA로 하고 일반적인 구현은 DFA로 해야 효율적이다. 그렇기 때문에 DFA에서 NFA로, NFA에서 DFA로의 변환을 필요로 하며 이 둘은 서로 변환 가능하다.
# ε-전이 NFA를 DFA로 변환  
![컴파일러3](https://github.com/potatoduck9/TIL/assets/125454578/baa52b5e-4da2-4fc2-afa5-440da65aff97)
* 위의 그림은 ε-전이 NFA를 그림으로 나타낸 것이다. 이런 ε-전이 NFA를 DFA로 변환하기 위해선 ε-closure 개념을 알아야 한다.
* ε-closure란 ε을 거쳐서 갈 수 있는 위치들을 나타낸 것이다. 예를 들면 ε-closure(0) = {0,1,2,4,7,8}, ε-closure(1) = {1,2,4}, ε-closure(3) = {1,2,3,4,6,7,8} 값이 나온다. ε-closure(0)은 0에서 ε을 통해 0,1,2,4,7,8을 갈 수 있고 0에서 3은 a를 거쳐야 하고 5는 b를 거쳐야 하기 때문에 ε-closure(0)에서는 3과 5가 나올 수 없다.
* 위의 예처럼 상태가 하나만 있는 것도 있지만 두 개가 있는 것도 있다. 예를 들어 ε-closure(0,9)가 있다고 가정한다면 이것은 ε-closure(0)와  ε-closure(9)를 합치면 된다. = {0,1,2,4,7,8,9,10}
* ε-closure 개념을 이용하면 ε-전이 NFA를 DFA로 쉽게 변환할 수 있다. START는 ε-closure(0)에서 한다. ε-closure(0) = {0,1,2,4,7,8}을 A라고 가정한 후 ε-closure(0)에서 입력 문자 a와 b를 통해 갈 수 있는 경로를 B와 C라고 가정한다. ε-closure(0)에서 입력 문자 a를 통해 갈 수 있는 곳은 3과 9이기 때문에 B는 ε-cl(3,9)가 되고 ε-closure(0)에서 입력 문자 b를 통해 갈 수 있는 곳은 5이기 때문에 C는 ε-cl(5)가 된다.
* 경로 B와 C를 구했으므로 경로 B와 C에서 입력 문자 a와 b를 통해 갈 수 있는 경로를 또 구하면 된다. 경로 B ε-cl(3,9)에서 a를 통해 갈 수 있는 곳은 ε-cl(3,9) 자기 자신이기 때문에 경로 B에서 a를 통해 갈 수 있는 경로는 B다. 입력 문자 b를 통해 갈 수 있는 곳은 5와 11이기 때문에 ε-cl(5,11)을 경로 D라고 가정한다.
* 이 과정을 계속 반복하여 경로가 더 이상 만들어지지 않는다면 밑에 있는 그림처럼 ε이 하나도 없어지고 DFA로 변환된 모습을 확인할 수 있다.

![컴파일러4](https://github.com/potatoduck9/TIL/assets/125454578/e3070740-55e1-4c14-b6b6-6aef5f847519)
# 두 개 이상의 상태전이 NFA를 DFA로 변환 
>M = ({q₀,q₁}, {0,1}, δ, q₀, {q₁}) <br>
>δ | 0    |   1 <br>
>q₀| {q₀,q₁} | {q₀} <br>
>q₁| ø     |   {q₀,q₁} <br>

![컴파일러5](https://github.com/potatoduck9/TIL/assets/125454578/7fcb7d6c-1dc0-4b3e-a435-db48d4542315)
* 위의 전이 함수와 그림을 보면 q₀에서 입력 문자 0을 받으면 q₀, q₁ 두 곳으로 이동할 수 있고 q₁에서도 입력 문자 1을 받으면 q₀, q₁ 두 곳으로 이동한다.
* 이것을 입력 문자를 받으면 오직 한곳으로 이동하는 DFA로 변환하기 위해선 {q₀,q₁}을 하나의 상태로 만들어 주면 된다.
>δ' | 0       |   1 <br>
>[q₀]| [q₀, q₁]    | [q₀] <br>
>[q₁]|    ø       | [q₀, q₁] <br>
>[q₀, q₁]| [q₀, q₁]| [q₀, q₁]  <br>
* 위에 있는 전의 함수는 DFA로 변환하기 위해 하나의 상태들로 만든 것들이다. 맨 밑에 새로 추가된 [q₀, q₁] 상태는 0과 1의 입력 문자를 받으면 [q₀], [q₁] 각각의 상태에서 입력 문자 0과 1을 받았을 때의 합집합 한 값이 나온다. 예를 들어 q₀ 상태에서 0을 입력받으면 [q₀, q₁] 값이 나오고 q₁에서 0을 입력받으면 ø 값이 나온다. 이 둘의 합집합은 [q₀, q₁] 값이 나오므로 [q₀, q₁]을 적어 주면 된다.
* [q₀] = a, [q₁] = b, [q₀, q₁] = c라고 한다면 전이 함수는 밑의 값으로 바꿀 수 있다.
>  δ' | 0 | 1 <br>
>  A  | C | A <br>
>  B  | ø | C <br>
>  C  | C | C  <br>
* 위의 전의 함수를 보면 시작 상태인 A에서 B로 가는 경로가 없기 때문에 B는 없는 상태로 취급할 수 있다. 그렇다면 상태 A와 C만 남기 때문에 두 상태의 관계만 그려주면 된다.
* 그림으로 보면 알 수 있듯이 하나의 상태가 입력 문자를 받는다면 두 개 이상의 상태로 가지 않고 오직 하나의 상태로 가는 DFA 형식으로 잘 변환된 것을 확인할 수 있다. 
  
![컴파일러6](https://github.com/potatoduck9/TIL/assets/125454578/258f02d8-3f92-4ddc-88ff-7acfb8022b8b)

# DFA의 상태 최소화 
* 유한 오토마타의 상태가 많으면 많을수록 프로그램의 크기도 커지기 때문에 상태들을 최소화하는 게 좋다.
* 상태들을 최소화하기 전의 상태전이도 그림 
  
![컴파일러7](https://github.com/potatoduck9/TIL/assets/125454578/4e852fee-024b-4295-9662-27208d148e3a)

![컴파일러8](https://github.com/potatoduck9/TIL/assets/125454578/a60c4138-b202-4f2d-8dc4-e04e5f914e5c)

* 위의 표는 DFA 상태전이도 그림을 표로 나타낸 것이다.
* 상태 A, B, C, D, E 중에서 상태 E는 종료 상태이기 때문에 상태 E를 2 나머지 상태를 1로 가정한다.
* 상태 A, B, C, D는 1 상태 E를 2로 가정했기에 입력 기호를 통해 다른 상태로 이동하는 경우도 숫자로 바꿔준다. 예를 들면 상태 A가 입력 기호 a를 통해 상태 B로 이동하고 b를 통해 상태 C로 이동하기에 상태 B와 상태 C는 숫자 1로 가정했기에 1, 1이 된다. 나머지도 이렇게 하면 다 1, 1로 바뀌지만 상태 D만 1, 2로 바뀐다. 이유는 상태 D가 입력 기호 b를 통해 상태 E(숫자 2로 가정)로 이동하기에 상태 D만 1,2가 된다.
* 상태 A, B, C는 입력 기호를 통해 상태 1, 1로 이동하지만 상태 D는 입력 기호를 통해 1, 2로 이동하기에 상태 D도 상태 E처럼 나머지 상태들과 구분을 해줘야 한다.
  
![컴파일러9](https://github.com/potatoduck9/TIL/assets/125454578/65ca98d7-844c-4a82-948b-fc44e74284ec)
* 상태 E가 3으로 바뀌었기 때문에 상태 D에서 입력 기호 b를 통해 상태 E로 가는 숫자는 2에서 3으로 바꿔주면 된다. 이 과정을 계속 반복하여 상태가 다른 것들을 모두 구분하면 밑의 표처럼 된다.
  
![컴파일러10](https://github.com/potatoduck9/TIL/assets/125454578/fb52229e-d7d0-4c32-bcae-fd7f4f574135)

* 표를 통해 상태전이도를 그리면 상태 최소화를 하기 전과 비교했을 때 상태가 하나 줄어든 것을 확인할 수 있다.
# 유한 오토마타 -> 정규문법
![컴파일러11](https://github.com/potatoduck9/TIL/assets/125454578/0fe73d56-4602-4d79-a9fe-711816ced52d)

* 위의 유한 오토마타를 정규문법으로 바꾸는 법은 간단하다. 상태 A가 입력 기호 a, b를 통해 상태 F로 갈 수 있기 때문에 정규문법으로 나타내면 A -> aF, A -> bF로 바꿀 수 있다.
![컴파일러12](https://github.com/potatoduck9/TIL/assets/125454578/612de829-35f5-47d2-9952-4f74bbc39def)

* 또 다른 유한 오토마타가 있다. 이것을 정규문법으로 바꾸면 A -> aA, A -> ba, A -> aB, B-> bC, C -> bD, D -> ε (상태 D는 종료 상태이기 때문에 ε로 나타낸다)로 바꿀 수 있다.
# 정규문법 -> 정규표현
* 정규문법을 정규표현으로 바꾸기 위해선 하나의 공식을 알아야 한다. 공식 :  X -> αX + β의 유일해는 X = α* B이다.
* 공식 증명 : X -> αX + β은 X -> αX, X -> β 두 개의 식을 합한 것이다. 이 두 개의 식으로 위의 공식을 증명할 수 있다. X -> αX에서 X -> β를 대입하면 X ->  αβ가 된다. 만약 X -> αX에서 X에 또 αX를 대입하고 X에 β를 대입하면  ααβ가 된다. 만약 X -> αX에서 X에 αX를 계속해서 대입한다면 α는 무수히 늘어나고 X에 β를 대입해야 식이 끝나므로 X -> αX + β의 해는 X = α* B라고 풀 수 있다.
* 아무튼 이 공식을 이용하면 정규문법은 정규표현으로 쉽게 바꿀 수 있다. S = aA + bS, A = aA + bA + b라는 정규문법이 있다고 가정하고 정규표현으로 바꾸면  A = aA + bA + b를 A = (a + b)A + b로 먼저 바꿔준다. 위의 공식과 똑같은 형태를 만들었기 때문에 (a + b)가 α, b가 β라고 생각하면 (a + b)*b가 된다.
* A = (a + b)*b이기 때문에 S = aA + bS 식을 공식과 같은 형태로 만들어 주고 A 대신  (a + b)*b를 대입하면 된다. S = aA + bS를 S= bS + aA로 순서만 바꾸면 공식과 똑같은 형태로 만들어졌기 때문에 b * a(a+b)*b 정규표현으로 나타낼 수 있다. 
* 또 다른 정규문법을 정규표현으로 바꾸기 - 정규 문법은 S = aS | bS | b라고 가정하고 이것을 정규표현으로 바꾼다면 |는 +로 바꿀 수 있기 때문에 S = aS + bS + b로 만들고 정규표현으로 바꾸면 된다. S = aS + bS + b를 S = (a + b)S + b로 만든 후 (a + b)를  α, b를  β라고 생각하면 S = (a + b)* +b 정규표현으로 나타낼 수 있다.

# 구문분석 
* 구문분석을 하는 과정에서 문장이 유도되는 과정을 트리 형태로 표현한 것을 유도트리라고 한다. 유도트리에는 유도 과정의 각 단계에서 문장 형태의 가장 왼쪽에 있는 논터미널 기호를 계속해서 대체하는 경우를 좌단유도(leftmost derivation)라 하며, 반대로 가장 오른쪽에 있는 논터미널 기호를 계속해서 대체하는 경우를 우단유도(right derivation)라 한다.

* P: S => aAS | a, A -> SbA | SS| ba
* 좌단유도는 논터미널이 있다면 왼쪽에 있는 논터미널부터 터미널기호로 만들어야 한다. <br>
![컴파일러13](https://github.com/potatoduck9/TIL/assets/125454578/095d6cac-be54-4d57-ae1e-f060f8ffbbb6)

* 우단유도는 논터미널이 있다면 오른쪽에 있는 논터미널부터 터미널기호로 만들어야 한다. <br>
![컴파일러14](https://github.com/potatoduck9/TIL/assets/125454578/fa72a9f1-aec5-4efa-bd3c-d740912ce3ec)

* 구문분석을 하는 방법은 크게 두 종류가 존재한다. 하나는 Top-down 구문분석이고 다른 하나는 Bottom-up 구문분석이다. 이 두 종류의 구문분석 방법은 유도 과정을 어떻게 하느냐에 따라 방법이 정해진다. 좌단유도를 하면 Top-down 방법, 우단유도를 하면 Bottom-up 방법으로 정해진다.

# context-free 문법이 가지고 있는 비효율적인 부분들 제거 
* context-free 언어는 자연언어를 표현하기 위해 도입되었으며, 정규언어보다 표현 범위가 넓어서 이것을 인식하는 푸시다운 오토마타를 구현하는 일은 유한 오토마타를 구현하는 일보다 훨씬 복잡하고 어렵다.
* 문장이 효율적으로 인식되기 위하여 context-free 문법이 가지고 있는 비효율적인 부분들인 모호성, 불필요한 생성 규칙, 모호성, ε-생성 규칙, 단일 생성 규칙, backtracking, left-recursion 등을 제거해야 한다.



  




  


 




    

  

  





  





  
  
 










