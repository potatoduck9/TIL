# 번역기의 종류
* 컴파일러와 인간이 의사 전달을 하기 위해서는 C, C++, JAVA 같은 고급언어가 필요하고, 이러한 고급언어로 작성된 프로그램을 컴퓨터가 인식할 수 있도록 저급언어로 번역해 주기 위해선 번역기가 필요하다.  
* 번역기의 종류에는 어셈블러, 컴파일러, 인터프리터, 프리프로세스 등이 있으며 이 중에서 가장 대표적인 번역기가 컴파일러이다. 
* 어셈블러는 번역기에 어셈블리어가 입력되면 기계어로 번역을 해준다. 
* 컴파일러는 고급언어를 저급언어로 번역을 해준다. 
* 인터프리터는 고급언어를 실행 결과로 번역을 해준다. (고급언어를 입력으로 받아들여서 번역과 동시에 실행을 한 후, 결과를 출력하기 때문에 APL, SNOBOL 등과 같은 대화용 언어를 구현할 경우 사용)
* 프리프로세서는 고급언어를 고급언어로 번역을 해준다. (프로그래밍 언어에 유용한 기능들을 추가하여 확장시켜 주는 역할을 함)

# 컴파일러와 인터프리터 
* 번역기들 중에서 고급언어로 작성된 프로그램을 입력 자료로 하여 번역하는 가장 대표적인 번역기는 컴파일러와 인터프리터이다. 
* 컴파일러 기법은 번역 후 실행하는 방식이고 인터프리터 기법은 번역과 실행을 동시에 하는 방식이다. (컴파일러가 번역기라면 인터프리터는 통역기인 셈)
* 컴파일러 기법은 번역 후 실행을 한 번에 하기 때문에 실행 속도가 빠른 장점이 있고 반복문 처리에도 효과가 있다. 반면 인터프리터 기법은 번역과 실행을 동시에 하기에 반복문 처리에는 적합하지 않다.
  * 컴파일러 기법을 사용하는 언어의 종류에는 PASCAL, C, C++, JAVA 등이 있다.
* 인터프리터 기법은 번역과 실행을 동시에 하기 때문에 한 줄 번역하고 실행하고 한 줄 번역하고 실행하기에 실행 시간이 긴 단점이 있지만 번역과 실행을 수행한 후 사용자에게 권한을 넘겨줘 사용자가 추가하고 싶은 것을 입력할 수 있는 장점도 있다. (사용자와 대화식) 반면 컴파일러 기법은 번역 후 한 실행을 한 번에 하기 때문에 사용자에게 권한을 주지 않는다. 
  * 인터프리터 기법을 사용하는 언어의 종류에는 LISP, APL, SNOBOL 등이 있다.

 # 컴파일러 논리적 구조 
 * 컴파일러는 일반적으로, 어휘 분석(lexical analysis) 단계, 구문 분석(syntax analysis) 단계, 의미 분석(semantic analysis) 단계, 중간 코드 생성(intermediate code generation) 단계, 코드 최적화(code optimization) 단계, 목적 코드 생성(code generation) 단계를 거쳐 저급언어로 번역된다.
 * 어휘 분석 단계에서는 기본어휘가 문법에 맞는지 분석하고 어휘를 토큰으로 변환한다.
 * 구문 분석 단계에서는 토큰으로 변환된 것 들이 문법에 맞는지 분석하고 분석 결과를 파스 트리로 출력한다.
 * 의미 분석 단계에서는 자료구조정의, 혼합형연산 등의 실행 전 사전작업을 해주고 컴파일러가 올바르게 수행될 수 있도록 환경을 조성한다.
 * 의미 분석 단계까지의 내용으로 코드를 생성해도 되지만 좀더 효율적으로 만들어 실행시 기억공간이나 실행시간을 절약하는 것이 필요하다. 이를 수행하는 것이 코드최적화이고 코드최적화가 되기 위해선 그 전에 중간코드가 생성되어야 한다. 중간코드는 최적화를 위한 중간단계이며 후위표현, 3주소코드, U코드, 문법지시적변환 등의 방식들을 사용하여 시간과 공간의 크기를 줄여준다.
 * 마지막 목적 코드 생성 단계에서는 최적화된 코드를 그대로 레지스터나 기억장소 위치를 정해서 목적코드로 생성해준다.

# 컴파일러 패스
* 패스란 컴파일러를 구현할 때 여러 논리적 단계들을 모아서 하나의 물리적 모듈로 묶은 것이다.
* 컴파일러는 위에서 말한 6단계의 논리적인 구조를 가지고 있고 이런 논리적인 구조를 실제 구현하게 되는 경우 1-패스 컴파일러 또는 2-패스 컴파일러 방법을 이용한다.
* 어휘 분석에서 중간 코드 단계까지 묶은 것을 1패스 최적화 단계에서 코드 생성 단계까지 묶은 것을 2패스라고 할 때 1-패스 컴파일러는 1패스와 2패스를 합해서 하나의 패스로 구성하는 방식이고 2-패스 컴파일러는 중간 코드를 기점으로 하여 전반부(1패스)와 후반부(2패스)로 구성하는 방식이다.
* 1-패스 컴파일러는 초창기에 컴파일러를 만들 때 사용되던 방식이다. 이 방식의 특징에는 실행 속도가 빠르고 효율성이 높은 장점이 있지만 backpatching이 요구되는 문제점도 있다.
  * backpatching(GOTO 문의 전방 점프나 IF 분기 구문 같은 경우에는 내부적으로 점프를 사용하는데 점프할 부분의 소스 코드가 읽히지 않으면 점프의 번지를 지정할 수 없는 상태이므로 중간 코드에 빠진 부분을 만들어 놓고 해당 점프의 목표 부분을 찾으면 점프의 번지를 결정한다)
* 2-패스 컴파일러는 컴파일러의 구성을 중간 코드를 기점으로 하여 앞 단계를 전반부, 뒤 단계를 후반부로 구성하는 방식이다. 이 방식의 특징에는 컴파일러의 구성을 2단계로 나누었기 때문에 기계 독립적이고 이식성이 좋으며 기억장소를 절약할 수 있는 장점이 있지만 실행 속도가 느린 문제점도 있다.

# 유한 오토마타 
* 유한 오토마타란 어떤 알파벳 T로부터 만들어지는 문자열의 특별한 것들을 받아들이는 시스템의 수학적 모델로서, 그 시스템의 변화할 수 있는 상태가 유한 개인 것이다.
* 유한 오토마타는 입력으로 문자열을 받아서, 그 문자열이 그 언어의 문장이면 "YES"를 답하고 그렇지 않으면 "NO"라고 답하는 프로그램으로 어휘 분석기는 유한 오토마타의 대표적인 예이다.
* 유한 오토마타를 표현하는 방식은 두 가지가 있다. 첫 번째 방식은 정의에 따라서 5가지의 구성 원소들을 형식(formal)에 맞게 정확히 표현하고 두 번째 방식은 상태전이도를 사용하여 비형식적(informal)으로 표현하는 방법인데 이 방식은 그림을 통하여 쉽게 개념이 들어오기 때문에 일반적으로 유한 오토마타를 설명할 때 상태전이도를 많이 사용한다.
![컴파일러](https://github.com/potatoduck9/TIL/assets/125454578/3607f5a1-72ed-4a52-872c-4846df8cf6ad)
* 위 그림은 유한 오토마타를 상태전이도를 사용하여 비형식적으로 표현하는 방법을 나타낸 것이다. 오토마타의 각 상태(state)를 노드로 나타내며(위 그림에서는 q₀, q₁) q₀에서 q₁으로 가는 지시선과 지시선 위에 영문자 입력 기호를 적는다. q₁은 종료 상태이기 때문에 이중 원으로 나타내고 q₀ 노드전에는 시작 상태를 표시하는 start 선을 하나 그려준다.
![컴파일러2](https://github.com/potatoduck9/TIL/assets/125454578/9e592c68-7cf7-4d32-a562-5f0475986e7f)
* 위 그림은 식별자를 c3a9로 가정하고 답을 어떻게 하는지 알아보는 그림이다. q₀에서  q₁으로 가는 지시선에 입력 문자 c가 있기 때문에 q₀에서 q₁으로 이동하고, 남은 식별자인 3a9는 q₁ 입력문자에 모두 있기 때문에 q₁에서 식별자를 모두 인식하고 마지막에 종료 상태가 된다.
* 예를 들어 식별자가 a = 7이라고 가정한다면 a는 입력 기호에 있기 때문에 q₀에서 q₁으로 이동할 수 있지만 다음 식별자인 기호 =는 q₁에서 인식을 하지 못하기 때문에 식별자가 아니다(NO)로 답한다.
* 유한 오토마타를 표현하는 또 다른 방식인 형식에 맞게 표현한다면 밑에 있는 기호들로 표현할 수 있다. 
   >M = (Q, Σ, δ, q₀, F) <br>
   >단 , Q = {q₀, q₁} <br>
   >Σ = {a,b,c,...,z,0,1,...,9} <br>
   >q₀ = q₀ F = {q₁} <br>
* 위에 있는 기호에서 Q는 상태를 의미하고 Σ는 입력 기호를 의미하고 δ는 전이 함수를 의미하고 q₀는 시작 상태 F는 종료 상태를 의미한다.
* 전이 함수를 의미하는 δ를 표현하면 밑의 식으로 표현할 수 있다.
>δ| a  b  c ...  z   |  0   1 .... 9 <br>
>q₀|q₁ q₁ q₁...q₁   | ø   ø.... ø <br>
>q₁|q₁ q₁ q₁...q₁   | q₁  q₁...q₁ <br>
* 입력 문자 a, b, c...z를 입력받으면 q₀에서 q₁으로 이동하기 때문에 q₁을 표시하고 숫자를 받으면 아무 곳으로 이동하지 못하기 때문에 공집합으로 표시한다. q₁은 영문자, 숫자를 입력받으면 q₁으로 이동할 수 있기 때문에 q₁을 표시한다.
# 유한 오토마타의 종류 
* 유한 오토마타의 종류에는 결정적 유한 오토마타(DFA)와 비결정적 유한 오토마타(NFA)가 있다.
  * 결정적 유한 오토마타는 하나의 입력 문자열에 대하여 오직 하나의 다음 상태가 결정되는 유한 오토마타이다.
  * 비결정적 유한 오토마타는 두 가지가 있는데 하나는 ε에 의한 전이가 있는 경우가 있고 또 다른 하나는 주어진 하나의 입력 기호를 보고 갈 수 있는 다음 상태가 두 개 이상 존재할 수 있는 유한 오토마타이다.
* 비결정적 유한 오토마타(NFA)는 언어의 구조를 쉽게 표현할 수 있지만 결정적 유한 오토마타(DFA)보다 프로그램으로 구현하기 힘들다. 반면 DFA는 NFA보다 프로그램으로 구현했을 때 효율 면에서 좋다. 그렇기 때문에 언어의 구조를 표현할 때는 NFA로 하고 일반적인 구현은 DFA로 해야 효율적이다. 그렇기 때문에 DFA에서 NFA로, NFA에서 DFA로의 변환을 필요로 하며 이 둘은 서로 변환 가능하다.
# ε-전이 NFA를 DFA로 변환  
![컴파일러3](https://github.com/potatoduck9/TIL/assets/125454578/baa52b5e-4da2-4fc2-afa5-440da65aff97)
* 위의 그림은 ε-전이 NFA를 그림으로 나타낸 것이다. 이런 ε-전이 NFA를 DFA로 변환하기 위해선 ε-closure 개념을 알아야 한다.
* ε-closure란 ε을 거쳐서 갈 수 있는 위치들을 나타낸 것이다. 예를 들면 ε-closure(0) = {0,1,2,4,7,8}, ε-closure(1) = {1,2,4}, ε-closure(3) = {1,2,3,4,6,7,8} 값이 나온다. ε-closure(0)은 0에서 ε을 통해 0,1,2,4,7,8을 갈 수 있고 0에서 3은 a를 거쳐야 하고 5는 b를 거쳐야 하기 때문에 ε-closure(0)에서는 3과 5가 나올 수 없다.
* 위의 예처럼 상태가 하나만 있는 것도 있지만 두 개가 있는 것도 있다. 예를 들어 ε-closure(0,9)가 있다고 가정한다면 이것은 ε-closure(0)와  ε-closure(9)를 합치면 된다. = {0,1,2,4,7,8,9,10}
* ε-closure 개념을 이용하면 ε-전이 NFA를 DFA로 쉽게 변환할 수 있다. START는 ε-closure(0)에서 한다. ε-closure(0) = {0,1,2,4,7,8}을 A라고 가정한 후 ε-closure(0)에서 입력 문자 a와 b를 통해 갈 수 있는 경로를 B와 C라고 가정한다. ε-closure(0)에서 입력 문자 a를 통해 갈 수 있는 곳은 3과 9이기 때문에 B는 ε-cl(3,9)가 되고 ε-closure(0)에서 입력 문자 b를 통해 갈 수 있는 곳은 5이기 때문에 C는 ε-cl(5)가 된다.
* 경로 B와 C를 구했으므로 경로 B와 C에서 입력 문자 a와 b를 통해 갈 수 있는 경로를 또 구하면 된다. 경로 B ε-cl(3,9)에서 a를 통해 갈 수 있는 곳은 ε-cl(3,9) 자기 자신이기 때문에 경로 B에서 a를 통해 갈 수 있는 경로는 B다. 입력 문자 b를 통해 갈 수 있는 곳은 5와 11이기 때문에 ε-cl(5,11)을 경로 D라고 가정한다.
* 이 과정을 계속 반복하여 경로가 더 이상 만들어지지 않는다면 밑에 있는 그림처럼 ε이 하나도 없어지고 DFA로 변환된 모습을 확인할 수 있다.

![컴파일러4](https://github.com/potatoduck9/TIL/assets/125454578/e3070740-55e1-4c14-b6b6-6aef5f847519)
# 두 개 이상의 상태전이 NFA를 DFA로 변환 
>M = ({q₀,q₁}, {0,1}, δ, q₀, {q₁}) <br>
>δ | 0    |   1 <br>
>q₀| {q₀,q₁} | {q₀} <br>
>q₁| ø     |   {q₀,q₁} <br>

![컴파일러5](https://github.com/potatoduck9/TIL/assets/125454578/7fcb7d6c-1dc0-4b3e-a435-db48d4542315)
* 위의 전이 함수와 그림을 보면 q₀에서 입력 문자 0을 받으면 q₀, q₁ 두 곳으로 이동할 수 있고 q₁에서도 입력 문자 1을 받으면 q₀, q₁ 두 곳으로 이동한다.
* 이것을 입력 문자를 받으면 오직 한곳으로 이동하는 DFA로 변환하기 위해선 {q₀,q₁}을 하나의 상태로 만들어 주면 된다.
>δ' | 0       |   1 <br>
>[q₀]| [q₀, q₁]    | [q₀] <br>
>[q₁]|    ø       | [q₀, q₁] <br>
>[q₀, q₁]| [q₀, q₁]| [q₀, q₁]  <br>
* 위에 있는 전의 함수는 DFA로 변환하기 위해 하나의 상태들로 만든 것들이다. 맨 밑에 새로 추가된 [q₀, q₁] 상태는 0과 1의 입력 문자를 받으면 [q₀], [q₁] 각각의 상태에서 입력 문자 0과 1을 받았을 때의 합집합 한 값이 나온다. 예를 들어 q₀ 상태에서 0을 입력받으면 [q₀, q₁] 값이 나오고 q₁에서 0을 입력받으면 ø 값이 나온다. 이 둘의 합집합은 [q₀, q₁] 값이 나오므로 [q₀, q₁]을 적어 주면 된다.
* [q₀] = a, [q₁] = b, [q₀, q₁] = c라고 한다면 전이 함수는 밑의 값으로 바꿀 수 있다.
>  δ' | 0 | 1 <br>
>  A  | C | A <br>
>  B  | ø | C <br>
>  C  | C | C  <br>
* 위의 전의 함수를 보면 시작 상태인 A에서 B로 가는 경로가 없기 때문에 B는 없는 상태로 취급할 수 있다. 그렇다면 상태 A와 C만 남기 때문에 두 상태의 관계만 그려주면 된다.
* 그림으로 보면 알 수 있듯이 하나의 상태가 입력 문자를 받는다면 두 개 이상의 상태로 가지 않고 오직 하나의 상태로 가는 DFA 형식으로 잘 변환된 것을 확인할 수 있다. 
  
![컴파일러6](https://github.com/potatoduck9/TIL/assets/125454578/258f02d8-3f92-4ddc-88ff-7acfb8022b8b)

# DFA의 상태 최소화 
* 유한 오토마타의 상태가 많으면 많을수록 프로그램의 크기도 커지기 때문에 상태들을 최소화하는 게 좋다.
* 상태들을 최소화하기 전의 상태전이도 그림 
  
![컴파일러7](https://github.com/potatoduck9/TIL/assets/125454578/4e852fee-024b-4295-9662-27208d148e3a)

![컴파일러8](https://github.com/potatoduck9/TIL/assets/125454578/a60c4138-b202-4f2d-8dc4-e04e5f914e5c)

* 위의 표는 DFA 상태전이도 그림을 표로 나타낸 것이다.
* 상태 A, B, C, D, E 중에서 상태 E는 종료 상태이기 때문에 상태 E를 2 나머지 상태를 1로 가정한다.
* 상태 A, B, C, D는 1 상태 E를 2로 가정했기에 입력 기호를 통해 다른 상태로 이동하는 경우도 숫자로 바꿔준다. 예를 들면 상태 A가 입력 기호 a를 통해 상태 B로 이동하고 b를 통해 상태 C로 이동하기에 상태 B와 상태 C는 숫자 1로 가정했기에 1, 1이 된다. 나머지도 이렇게 하면 다 1, 1로 바뀌지만 상태 D만 1, 2로 바뀐다. 이유는 상태 D가 입력 기호 b를 통해 상태 E(숫자 2로 가정)로 이동하기에 상태 D만 1,2가 된다.
* 상태 A, B, C는 입력 기호를 통해 상태 1, 1로 이동하지만 상태 D는 입력 기호를 통해 1, 2로 이동하기에 상태 D도 상태 E처럼 나머지 상태들과 구분을 해줘야 한다.
  
![컴파일러9](https://github.com/potatoduck9/TIL/assets/125454578/65ca98d7-844c-4a82-948b-fc44e74284ec)
* 상태 E가 3으로 바뀌었기 때문에 상태 D에서 입력 기호 b를 통해 상태 E로 가는 숫자는 2에서 3으로 바꿔주면 된다. 이 과정을 계속 반복하여 상태가 다른 것들을 모두 구분하면 밑의 표처럼 된다.
  
![컴파일러10](https://github.com/potatoduck9/TIL/assets/125454578/fb52229e-d7d0-4c32-bcae-fd7f4f574135)

* 표를 통해 상태전이도를 그리면 상태 최소화를 하기 전과 비교했을 때 상태가 하나 줄어든 것을 확인할 수 있다.
# 유한 오토마타 -> 정규문법
![컴파일러11](https://github.com/potatoduck9/TIL/assets/125454578/0fe73d56-4602-4d79-a9fe-711816ced52d)

* 위의 유한 오토마타를 정규문법으로 바꾸는 법은 간단하다. 상태 A가 입력 기호 a, b를 통해 상태 F로 갈 수 있기 때문에 정규문법으로 나타내면 A -> aF, A -> bF로 바꿀 수 있다.
![컴파일러12](https://github.com/potatoduck9/TIL/assets/125454578/612de829-35f5-47d2-9952-4f74bbc39def)

* 또 다른 유한 오토마타가 있다. 이것을 정규문법으로 바꾸면 A -> aA, A -> ba, A -> aB, B-> bC, C -> bD, D -> ε (상태 D는 종료 상태이기 때문에 ε로 나타낸다)로 바꿀 수 있다.
# 정규문법 -> 정규표현
* 정규문법을 정규표현으로 바꾸기 위해선 하나의 공식을 알아야 한다. 공식 :  X -> αX + β의 유일해는 X = α* B이다.
* 공식 증명 : X -> αX + β은 X -> αX, X -> β 두 개의 식을 합한 것이다. 이 두 개의 식으로 위의 공식을 증명할 수 있다. X -> αX에서 X -> β를 대입하면 X ->  αβ가 된다. 만약 X -> αX에서 X에 또 αX를 대입하고 X에 β를 대입하면  ααβ가 된다. 만약 X -> αX에서 X에 αX를 계속해서 대입한다면 α는 무수히 늘어나고 X에 β를 대입해야 식이 끝나므로 X -> αX + β의 해는 X = α* B라고 풀 수 있다.
* 아무튼 이 공식을 이용하면 정규문법은 정규표현으로 쉽게 바꿀 수 있다. S = aA + bS, A = aA + bA + b라는 정규문법이 있다고 가정하고 정규표현으로 바꾸면  A = aA + bA + b를 A = (a + b)A + b로 먼저 바꿔준다. 위의 공식과 똑같은 형태를 만들었기 때문에 (a + b)가 α, b가 β라고 생각하면 (a + b)*b가 된다.
* A = (a + b)*b이기 때문에 S = aA + bS 식을 공식과 같은 형태로 만들어 주고 A 대신  (a + b)*b를 대입하면 된다. S = aA + bS를 S= bS + aA로 순서만 바꾸면 공식과 똑같은 형태로 만들어졌기 때문에 b * a(a+b)*b 정규표현으로 나타낼 수 있다. 
* 또 다른 정규문법을 정규표현으로 바꾸기 - 정규 문법은 S = aS | bS | b라고 가정하고 이것을 정규표현으로 바꾼다면 |는 +로 바꿀 수 있기 때문에 S = aS + bS + b로 만들고 정규표현으로 바꾸면 된다. S = aS + bS + b를 S = (a + b)S + b로 만든 후 (a + b)를  α, b를  β라고 생각하면 S = (a + b)* +b 정규표현으로 나타낼 수 있다.

# 구문분석 
* 구문분석을 하는 과정에서 문장이 유도되는 과정을 트리 형태로 표현한 것을 유도트리라고 한다. 유도트리에는 유도 과정의 각 단계에서 문장 형태의 가장 왼쪽에 있는 논터미널 기호를 계속해서 대체하는 경우를 좌단유도(leftmost derivation)라 하며, 반대로 가장 오른쪽에 있는 논터미널 기호를 계속해서 대체하는 경우를 우단유도(right derivation)라 한다.

* P: S => aAS | a, A -> SbA | SS| ba
* 좌단유도는 논터미널이 있다면 왼쪽에 있는 논터미널부터 터미널기호로 만들어야 한다. <br>
![컴파일러13](https://github.com/potatoduck9/TIL/assets/125454578/095d6cac-be54-4d57-ae1e-f060f8ffbbb6)

* 우단유도는 논터미널이 있다면 오른쪽에 있는 논터미널부터 터미널기호로 만들어야 한다. <br>
![컴파일러14](https://github.com/potatoduck9/TIL/assets/125454578/fa72a9f1-aec5-4efa-bd3c-d740912ce3ec)

* 구문분석을 하는 방법은 크게 두 종류가 존재한다. 하나는 Top-down 구문분석이고 다른 하나는 Bottom-up 구문분석이다. 이 두 종류의 구문분석 방법은 유도 과정을 어떻게 하느냐에 따라 방법이 정해진다. 좌단유도를 하면 Top-down 방법, 우단유도를 하면 Bottom-up 방법으로 정해진다.

# context-free 문법이 가지고 있는 비효율적인 부분들 제거 
* context-free 언어는 자연언어를 표현하기 위해 도입되었으며, 정규언어보다 표현 범위가 넓어서 이것을 인식하는 푸시다운 오토마타를 구현하는 일은 유한 오토마타를 구현하는 일보다 훨씬 복잡하고 어렵다.
* 문장이 효율적으로 인식되기 위하여 context-free 문법이 가지고 있는 비효율적인 부분들인 모호성, 불필요한 생성 규칙, 모호성, ε-생성 규칙, 단일 생성 규칙, backtracking, left-recursion 등을 제거해야 한다.
# 모호성 제거 
> E -> E + E <br>
> E -> E - E <br>
> E -> E * E <br>
> E -> E / E <br>
> E -> 0|1|2|3|4|5
* 3 + 4 * 5 문장을 유도한다고 했을 때 위의 문법으로 3 + 4 * 5 문장을 유도할 수 있다.
![컴파일러15](https://github.com/potatoduck9/TIL/assets/125454578/14e27616-b9fd-4b71-b6a3-add91d40e57c)

* 문법을 통해 3 + 4 * 5 문장을 유도했지만 이 문법에는 문제점이 있다. 한 가지 문법을 통해 딱 하나의 유도만 해야 효율성이 있지만 3 + 4 * 5를 유도할 때 하나 이상의 유도가 만들어 졌기 때문에 효율성이 많이 떨어지는 문제가 있다. 이러한 문제를 해결하기 위해선 모호성을 제거해야 한다.
* 모호한 문법은 연산자 우선순위(precedence)와 결합법칙(associativity)을 이용하여 모호하지 않은 문법으로 바꿀 수 있다.
* 연산자 우선순위 방법은 문법을 통해 문장을 유도할 때 +, - 연산자를 먼저 사용하고 *, / 연산자를 후에 사용하는 방법이다.
* 결합법칙은 연산자 우선순위 방법을 사용할 때 우선순위가 같은 연산자를 동시에 사용하게 된다면 왼쪽에 있는 연산자 부터 먼저 사용하는 방법이다.
# 불필요한 생성규칙 제거 
* 불필요한 생성규칙을 제거 하기 위해선 터미널 기호를 생성할 수 없는 논터미널 기호를 먼저 제거한 후 시작 기호로부터 도달 불가능한 기호를 제거한다.
> S -> AB <br>
> S -> a  <br>
> A -> a  <br>
* S -> AB는 B가 터미널 기호를 생성하지 못하므로 제거 한다.
> S -> a  <br>
> A -> a  <br>
* 시작 기호 S에서 논터미널 기호 A로 도달이 불가능하므로 논터미널 A도 제거 한다.
* 그럼 불필요한 생성 규칙들은 모두 제거 되고 S -> a만 남게 된다.
# ε-생성 규칙의 제거 
* ε- 생성규칙 제거 문법은 ε-생성규칙을 갖지 않고 시작기호 S -> ε인 경우, 생성규칙의 오른쪽에 S가 없어야 한다.
* 만약 ε- 생성규칙 제거 문법의 조건을 충족하지 못한다면 S에 ε을 대입해서 생성될 수 있는 모든 생성규칙을 P'에 첨가하고 S -> ε 대신 S' -> S | ε을 추가해서  ε- 생성규칙 제거 문법을 만들어 줘야 한다.
> P : S -> aSbS <br>
> S -> bSaS <br>
> S -> ε <br>
* 위의 문법은 ε- 생성규칙 제거 문법의 조건을 충족하지 못했기에 ε- 생성규칙 제거 문법으로 만들어 줘야 한다.
> P ': S' -> S | ε <br>
> S -> aSbS | bSaS <br>
> S -> aSb|abS|ab|bSa|baS|ba <br>
* 위의 문법은 ε- 생성규칙 제거 문법의 조건을 충족하지 못한 문법을 ε- 생성규칙 제거 문법으로 바꾼것이다.
# 단일 생성규칙 제거 
> P : E -> E + T | T <br>
> T -> T * F | F <br>
> F -> (E) | a <br>
* 위의 문법에는 단일 생성규칙이 2개가 있다. E -> E + T | T에서 T와 T -> T * F | F에서 F가 단일 생성규칙이다. 이 문법은 매우 비효율적이다. 왜냐하면 E를 통해 T를 유도할 때 T가 유도하고 있는 곳으로 한 번 더 이동해야 하고 T를 통해 F를 유도할 때 F가 유도하고 있는 곳으로 한 번 더 이용해야 하기 때문에 비효율적이다.
* 이것을 효율적으로 해결하기 위해선 E를 통해 T를 유도할 때, T를 통해 F를 유도할 때 T, F를 적지 말고 T, F가 유도할 수 있는 문법을 적으면 한 번 더 이동하지 않고 바로 유도할 수 있다.
* 단일 생성규칙을 제거한 문법은 밑의 문법처럼 바꿀 수 있다. 
> P ' : E -> E + T | T * F | (E) | a <br>
> T -> T * F | (E) | a <br>
> F -> (E) | a <br>
# Backtracking 와 Left-factoring
* backtracking은 같은 기호들을 prefix로 갖는 2개 이상의 생성규칙이 존재할 경우 발생하는 데 이를 해결하기 위하여 left-factoring을 해야 한다. left-factoring은 공통된 prefix를 인수분해 하는 것이다.
> S -> cAd <br>
> A -> a | ab <br>
* 위의 문법을 통해 cabd를 유도할 때 S -> cAd에서 논터미널 A를 통해 ab를 유도하면 cabd가 제대로 유도되지만 논터미널 A를 통해 a를 유도하면 cad가 유도되어 원하는 값인 cabd를 유도하지 못하여 다시 논터미널 A로 돌아가서 올바른 값인 ab를 유도 해야 한다. 이때 다시 논터미널 A로 돌아가는 것을 backtracking이라고 한다.
* backtracking이 발생하면 컴파일러의 효율이 떨어진다. 
* backtracking은 같은 prefix를 갖는 생성 규칙들이 존재하면 발생한다. 여기서 같은 prefix란 위의 문법처럼 논터미널 A가 a | ab의 두 문자를 유도하는데 이 때 두 문자의 첫 글자가 같은것을 의미한다(첫 글자 a). 이것을 해결하기 위해선 공통된 prefix를 인수분해 해야 한다.(Left-Factoring)
> S -> cAd <br>
> A -> aA' <br>
> A' -> ε | b <br>
* prefix를 인수분해 하면 위의 문법처럼 만들어지고 위의 문법을 이용하여 cabd를 유도하면 backtracking이 발생하지 않게 된다.
![컴파일러16](https://github.com/potatoduck9/TIL/assets/125454578/951a70dc-e45c-43f6-8c9a-9cedf97ee52d)
> S -> iEtS | iEtSeS | a <br>
> E -> b <br>
* 위의 문법에서도 iEtS 공통된 prefix가 있기 때문에 Left-Factoring을 해줘야 한다.
> S -> iEtSS' | a <br>
> S' -> ε | eS <br>
> E -> b <br>
# Left-recurison 제거 (Top - down 구문분석)
> A -> Aα <br>
* 위의 문법은 Top-down 구문 분석이기 때문에 좌단유도를 해야 한다.
* 앞의 문자가 A로 같기 때문에 생성 규칙이 반복적으로 적용되어 무한 루프에 빠지게 된다.
* 그렇기 때문에 Right-recursion으로 변환해야 한다.
> A -> αA <br>

> P : E -> E + T | T <br>
* 위의 문법을 보면 E -> E + T에서 E 때문에 또 E + T + T가 되고 또 E + T + T + T가 만들어진다. 무한 루프에 빠지게 되므로 이 문법을 Right-recursion으로 변환해야 한다.
* E는 T로 변환되어야 무한 루프가 끝나고 뒤에 문자는 +T로 이어지는 형태를 보인다. 이것을 활용해서 Right-recursion으로 변환해 주면 된다.
> E -> TE' <br>
> E'-> +TE' | ε <br>

> P : T -> T * F | F <br>
* 위의 문법도 보면 T -> T * F에서 T를 통해 T * F가 계속해서 생성되는 무한 루프가 만들어진다. 이것도 T가 F로 변환되어야 무한 루프가 끝나고 뒤에 문자는 *F로 이어지는 형태를 보이기에 이것을 활용해서 문법을 Right-recursion으로 변환해 주면 된다.
> T -> FT' <br>
> T' -> *FT' | ε <br>
# 구문분석 Top-Down 방법과 Bottom-Up 방법
* 구문분석 방법은 크게 Top-Down 방법과 Bottom-Up 방법의 두 종류로 나누어 볼 수 있다. Top-Down 방법은 시작 기호로부터 시작하여 정의된 문법의 규칙들을 적용하여 유도에 의한 주어진 문자열을 찾아가는 방법이고, Bottom-Up 방법은 입력된 문자열에서 감축(reduce)에 의해 시작 기호를 찾아가는 방법이다. (여기서 감축(reduce)이란 유도과정을 거꾸로 적용한 것. 즉 S ⇒ αAw ⇒ αβw의 유도과정이 존재할 때, 문장 형태 αβw에서 β를 A로 대체하는 것을 말한다.)
* Top- Down 방법의 예 -
![컴파일러17](https://github.com/potatoduck9/TIL/assets/125454578/9e692155-bb6e-4ea7-a4fc-6282cd74a469)

* Bottom-Up 방법의 예 -
![컴파일러18](https://github.com/potatoduck9/TIL/assets/125454578/11bd87c9-2365-4337-a15f-ab9d96bfdf3d)

* Bottom-Up 방법의 예에서 노란색으로 표시한 부분을 감축(reduce) 하면되고 표시한 감축되는 부분들을 핸들(handle)이라고 한다.
# Shift-Reduce 구문분석 
* Bottom-Up 구문분석의 방법으로 스택과 입력 버퍼 등을 사용하는 Shift-Reduce 구문분석이 있다. shift와 reduce를 사용하여 진행하는데 시작 기호가 나오면 올바른 문장으로 accept 된 것이다.
* shift는 입력 기호를 스택에 넣어주는 것이고 reduce는 스택에 있는 입력 기호를 가져와서 문법에 맞게 reduce 해주는 것을 의미한다.
* 입력 버퍼에 값이 들어가 있을 때 어떤 방식으로 처리를 할지 결정해 주는 구동 프로그램도 가지고 있다. 이 구동 프로그램은 파싱표를 이용하여 방식을 결정해 준다.
* Shift-Reduce 구문분석의 예 -

![컴파일러19](https://github.com/potatoduck9/TIL/assets/125454578/5f24d142-b440-4e46-b1c4-fdba222d8bd0)
* 구문분석 행동을 알기 위해서는 파싱표를 필요로 하기 때문에 파싱표가 어떻게 구성되고 어떻게 만들어지는지도 알아야 한다.
# FIRST
* FIRST는 파싱표가 구성될 때 쓰이는 방식 중 하나이다.
* FIRST(A)는 A로부터 유도되어 첫 번째로 나타날 수 있는 터미널 기호들의 집합이다.
> E -> TE' <br>
> E'-> +TE' | ε <br> 
> T -> FT' <br>
> T'-> *FT' | ε <br>
> F -> (E)  | id <br>

* 위의 문법을 활용하여 FIRST(E)를 구하면 E -> TE'에서 E를 통해 유도되는 터미널 기호들이 없기 때문에 맨 처음 유도되는 T를 통해 유도되는 것을 찾는다. T -> FT'에서 T를 통해 유도되는 터미널 기호가 또 없기 때문에 F를 통해 유도되는 터미널 기호를 찾는다. F에서 유도되는 (E)와 id에서 (, id는 터미널 기호이기 때문에 결국 FIRST(E) = {(,id}가 된다.
* FIRST(E')를 구하면 E'를 통해 유도되는 터미널 기호들은 +, ε가 있기 때문에 FIRST(E') = {+,ε}가 된다.
* FIRST(T)를 구하면 T를 통해 유도되는 터미널 기호들은 없기 때문에 맨 처음 유도되는 F를 통해 유도되는 터미널 기호들을 찾으면 된다. F를 통해 유도되는 터미널 기호들은 (, id가 있기 때문에 FIRST(T) = {(,id}가 된다.
# FOLLOW
* FOLLOW 또한 파싱표가 구성될 때 쓰이는 방식 중 하나이다.
* FOLLOW(A)는 어떤 문장 형태에 있어서, 논터미널 A 다음에 나타나는 터미널 기호들의 집합이다.
> E -> TE' <br>
> E'-> +TE' <br>
> E'-> ε  <br>
> T -> FT' <br>
> T'-> *FT'<br>
> T' -> ε <br>
> F -> (E) <br>
> F -> id <br>

* 위의 문법을 활용하여 FOLLOW(E)를 구하면 E는 시작 기호이기 때문에 '$'가 포함되고 F -> (E)에서 E 뒤에 터미널 기호인 )가 있기에 FOLLOW(E) = {$,)}가 된다.
* FOLLOW(E')를 구하면 E' 뒤에는 어떠한 터미널 기호가 없다. 하지만 FOLLOW(E') ⊃ FOLLOW(E)를 통해 E가 가지고 있는 터미널 기호를 E'도 가질 수 있기 때문에 FOLLOW(E') = {$,)}가 된다.
* FOLLOW(T)를 구하면 T 뒤에는 어떠한 터미널 기호가 없다. 하지만 E->TE'를 통해 T 뒤에 있는 논터미널 기호인 E'를 통해 유도되는 터미널 기호들을 가질 수 있다. 논터미널 기호인 E'는 E'->+TE'에서 터미널 기호 +를 유도하고 ε을 유도한다. FOLLOW에서 ε은 제외하기 때문에 FOLLOW(T)는 E'를 통해 {+}가 된다. 또 FOLLOW(T) ⊃ FOLLOW(E)를 통해 E가 가지고 있는 터미널 기호를 T도 가질 수 있기 때문에 FOLLOW(T) = {$,),+}가 된다. 

  
  


























  



  




  


 




    

  

  





  





  
  
 










